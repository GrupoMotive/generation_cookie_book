# Introdução ao JavaScript

O C# (pronuncia-se "See Sharp") é uma linguagem de programação moderna desenvolvida pela Microsoft, orientada a objeto e fortemente digitada. O C# permite que os desenvolvedores criem muitos tipos de aplicativos seguros e robustos que são executados no .NET. O C# tem suas raízes na família de linguagens C e os programadores em C, C++, Java e JavaScript a reconhecerão imediatamente. [do C#.](https://docs.microsoft.com/pt-br/dotnet/csharp/tour-of-csharp/tutorials/)

## O que é o JavaScript

O C# é uma linguagem de programação orientada a objeto* orientada a componentes. O C# fornece constructos de linguagem para dar suporte direto a esses conceitos, tornando o C# uma linguagem natural na qual criar e usar componentes de software. Desde sua origem, o C# adicionou recursos para dar suporte a novas cargas de trabalho e práticas de design de software emergentes. 




## Ambiente de Trabalho C# Visual Studio Code


**O Microsoft Visual Studio** é um [ambiente de desenvolvimento integrado](https://en.wikipedia.org/wiki/Integrated_development_environment "Ambiente de desenvolvimento integrado") (IDE) da [Microsoft](https://en.wikipedia.org/wiki/Microsoft "Microsoft") . Ele é usado para desenvolver [programas de computador](https://en.wikipedia.org/wiki/Computer_program "Programa de computador") , bem como [sites](https://en.wikipedia.org/wiki/Web_site "Web site") , [aplicativos da](https://en.wikipedia.org/wiki/Web_app "Aplicativo web") [web](https://en.wikipedia.org/wiki/Web_service "serviço de internet") , [serviços da web](https://en.wikipedia.org/wiki/Web_service "Web service") e [aplicativos móveis](https://en.wikipedia.org/wiki/Mobile_app "Mobile app") . O Visual Studio usa plataformas de desenvolvimento de software da Microsoft, como [API do](https://en.wikipedia.org/wiki/Windows_API "API do Windows") [Windows](https://en.wikipedia.org/wiki/Windows_Forms "Formulários do Windows") , [Windows Forms](https://en.wikipedia.org/wiki/Windows_Forms "Windows Forms") , [Windows Presentation Foundation](https://en.wikipedia.org/wiki/Windows_Presentation_Foundation "Windows Presentation Foundation") , [Windows Store](https://en.wikipedia.org/wiki/Windows_Store "Loja do Windows") e [Microsoft Silverlight](https://en.wikipedia.org/wiki/Microsoft_Silverlight "Microsoft Silverlight") . Pode produzir tanto [código nativo](https://en.wikipedia.org/wiki/Machine_code "Código da máquina") e [código gerenciado](https://en.wikipedia.org/wiki/Managed_code "Código gerenciado") .

O Visual Studio inclui um [editor de código](https://en.wikipedia.org/wiki/Code_editor "Editor de código") compatível com [IntelliSense](https://en.wikipedia.org/wiki/IntelliSense "IntelliSense") (o componente de [conclusão de código](https://en.wikipedia.org/wiki/Code_completion "Conclusão do código") ), bem como [refatoração de código](https://en.wikipedia.org/wiki/Code_refactoring "Refatoração de código") . O depurador integrado funciona como um depurador de nível de origem e um depurador de nível de máquina. Outras ferramentas [internas](https://en.wikipedia.org/wiki/Profiling_(computer_programming) "Profiling (programação de computador)") incluem um [criador de perfil de código](https://en.wikipedia.org/wiki/Profiling_(computer_programming) "Profiling (computer programming)") , designer para criar aplicativos [GUI](https://en.wikipedia.org/wiki/GUI "GUI") , [web designer](https://en.wikipedia.org/wiki/Web_designer "Web designer") , designer de [classe](https://en.wikipedia.org/wiki/Class_(computing) "Classe (computação)") e designer de [esquema de banco de dados](https://en.wikipedia.org/wiki/Database_schema "Esquema de banco de dados") . Ele aceita plug-ins que expandem a funcionalidade em quase todos os níveis - incluindo a adição de suporte para sistemas de [controle de origem](https://en.wikipedia.org/wiki/Source_control "Fonte de controle") (como [Subversion](https://en.wikipedia.org/wiki/Subversion_(software) "Subversão (software)") e [Git](https://en.wikipedia.org/wiki/Git "vai")) e adicionar novos conjuntos de ferramentas como editores e designers visuais para [linguagens](https://en.wikipedia.org/wiki/Domain-specific_language "Idioma específico do domínio") ou conjuntos de ferramentas [específicos de domínio](https://en.wikipedia.org/wiki/Domain-specific_language "Domain-specific language") para outros aspectos do [ciclo de vida de desenvolvimento de software](https://en.wikipedia.org/wiki/Software_development_lifecycle "Ciclo de vida de desenvolvimento de software") (como o cliente [Azure DevOps](https://en.wikipedia.org/wiki/Azure_DevOps_Server "Servidor Azure DevOps") : Team Explorer).

O Visual Studio oferece suporte a 36 [linguagens de programação](https://en.wikipedia.org/wiki/Programming_language "Linguagem de programação") diferentes e permite que o editor de código e o depurador ofereçam suporte (em graus variados) a praticamente qualquer linguagem de programação, desde que exista um serviço específico de linguagem. As linguagens incorporadas incluem [C](https://en.wikipedia.org/wiki/C_(programming_language) "C (linguagem de programação)") , [[9]](https://en.wikipedia.org/wiki/Microsoft_Visual_Studio#cite_note-9)  [C++](https://en.wikipedia.org/wiki/C%2B%2B "C++") , [C++/CLI](https://en.wikipedia.org/wiki/C%2B%2B/CLI "C++/CLI") , [Visual Basic .NET](https://en.wikipedia.org/wiki/Visual_Basic_.NET "Visual Basic .NET") , [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language) "C Sharp (linguagem de programação)") , [F#](https://en.wikipedia.org/wiki/F_Sharp_(programming_language) "F Sharp (linguagem de programação)") , [[10]](https://en.wikipedia.org/wiki/Microsoft_Visual_Studio#cite_note-10)  [JavaScript](https://en.wikipedia.org/wiki/JavaScript "JavaScript") , [TypeScript](https://en.wikipedia.org/wiki/TypeScript "TypeScript") , [XML](https://en.wikipedia.org/wiki/XML "XML") , [XSLT](https://en.wikipedia.org/wiki/XSLT "XSLT") , [HTML](https://en.wikipedia.org/wiki/HTML "HTML") e [CSS](https://en.wikipedia.org/wiki/Cascading_Style_Sheets "Folhas de estilo em cascata") . Suporte para outras linguagens como [Python](https://en.wikipedia.org/wiki/Python_(programming_language) "Python (linguagem de programação)") , [[11]](https://en.wikipedia.org/wiki/Microsoft_Visual_Studio#cite_note-11)  [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language) "Ruby (linguagem de programação)") , [Node.js](https://en.wikipedia.org/wiki/Node.js "Node.js"), e [M,](https://en.wikipedia.org/wiki/MUMPS "CAXUMBA") entre outros, está disponível por meio de [plug-ins](https://en.wikipedia.org/wiki/Plug-in_(computing) "Plug-in (computação)") . [Java](https://en.wikipedia.org/wiki/Java_(programming_language) "Java (linguagem de programação)") (e [J#](https://en.wikipedia.org/wiki/J_Sharp "J Sustenido") ) eram suportados no passado.

## Instalando a IDE Visual Studios Code

A instalação do Visual Studio é muito simples. Primeiramente, precisamos ter o arquivo de
instalação da IDE, isso é bem fácil de encontrar. Eu estou indicando o site oficial do Visual Studio 2022 que segue o link:
https://visualstudio.microsoft.com/pt-br/downloads/

![enter image description here](https://i.imgur.com/Ssvkn2o.png)

Escolha a opção Comunidade do seu sistema operacional.

O Visual Studio comunidade é gratuito as outras opções são pagas e possuem apenas uma versão de avaliação gratuita.

Com o download realizado com sucesso abra o arquivo instalador do Visual Studio

![enter image description here](https://i.imgur.com/3WACKOj.png)

Selecione a opção Asp.net e desenvolvimento web. E execute o download/instalação

![enter image description here](https://i.imgur.com/CdvGXSi.png)

Agora Vamos instalar o ASP.NET JDK 5 entre no link abaixo e selecione a opção do seu sistema operacional e a versão do seu processador

![enter image description here](https://i.imgur.com/pPcYtim.png)

depois de realizado o download instale o ASP.NET JDK 5  clicando no instalador e avançando os passos do instalador.



| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | **IMPORTANTE:** *Realizar o download do Visual Studio 2022 e do SDK.5.0.404 do asp.net core e  manter instalado em sua maquina.* |
| ------------------------------------------------------------ | ------------------------------------------------------------ |



## Entrada e Saída de dados

Basicamente toda a programação consiste em três etapas, a primeira é a entrada de
dados, onde o sistema irá receber os dados do usuário, a segunda etapa é o
processamento de dados, que é uma etapa que não é possível prever quando o usuário
irá executar mas que basicamente irá processar (manipular) os dados e fazer a sua
visualização ou mesmo o seu armazenamento e por fim teremos a terceira etapa, a saída
de dados, onde poderemos ter diversas formas de retorno de informações para o
usuário, como por exemplo, em um monitor, em um display, em um led, em uma
impressora e etc.

![enter image description here](https://i.imgur.com/PeY3kXN.png)

```html

<!DOCTYPE html>
<html>
<body>

<h2>What Can JavaScript Do?</h2>

<p id="demo">JavaScript can change HTML content.</p>

<button type="button" onclick='document.getElementById("demo").innerHTML = "Hello JavaScript!"'>Click Me!</button>

</body>
</html>

```



Em nosso exemplo, nosso programa apenas imprime “Hello World” na tela. Para fazer
isso, usamos o método console.log Todo texto (string) em C#é delimitado por
aspas duplas, e toda instrução(comando) deve terminar com um ponto e vírgula. Note
também que o texto “Hello World” está entre parênteses, que indica o início e término
de um parâmetro do método.

```javascript
console.log("Hello, World");
```



| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="300px"/> | **Alerta de BSM:** *Sempre importante utilizar atenção aos detalhes nos detalhes de fechamento de escopo com as chaves termino de instrução com ;* |
| ------------------------------------------------------------ | :----------------------------------------------------------- |



### Método prompt();

O método prompt()  que implementa operações
de entrada de dados pelo teclado.

**Entrada de texto digitado pelo usuário**

```javascript
string userName = prompt();
```

retorna uma cadeia de caracteres simples, ou seja, que não usa o
caractere espaço em branco;


**Exemplo de um programa ulizando a classe Scanner:**

```javascript
var signo = prompt("Qual é o seu signo?");

if (signo.toLowerCase() == "escorpião") {
  alert("Legal! Eu sou de Escorpião também!");
}

// há muitas formas de se usar o recurso prompt
var sign = window.prompt(); // abrir uma janela de promtpt em branco
var sign = prompt();       //  abrir uma janela de promtpt em branco
var sign = window.prompt('Você está se sentindo com sorte'); // abrir uma janela com o texto "Você está se sentindo com sorte"
var sign = window.prompt('Você está se sentindo com sorte', 'certamente'); // abrir uma janela com o texto "Você está se sentindo com sorte" e com o valor padrão "certamente"
```

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="300px"/> | **Alerta de BSM:** *Sempre importante utilizar a comunicação para a leitura dos materias e para perguntar para o instrutor caso tenha duvida* |
| ------------------------------------------------------------ | :----------------------------------------------------------- |



## Declaração de Variáveis e Constantes

### Variável

Para criar um idenficador (nome da variável) em C#, precisamos seguir algumas
regras, listadas a seguir:

>  - Deve conter apenas letras, _ (underline), $ ou os números de 0 a 9.
>  - Deve obrigatoriamente se iniciar por uma letra (preferencialmente),     ou $.
>   - Deve iniciar com uma letra minúscula (boa práca).   Não pode    conter espaços Não podemos usar palavras-chave da linguagem .
>    - O nome deve ser único dentro de um escopo

Além disso, o C# é case sensive, o que significa que os nomes de variáveis
diferenciam maiúsculas de minúsculas.

Sintaxe:

onde **tipo** é tipo de dado que a varável irá armazenar, **idenficador** é seu nome, e **valor**
é o valor inicial atribuído à variável, o qual é opcional (denotado pelos colchetes, que
não devem ser digitados na declaração).

Exemplo de declaração de variáveis:

```c#
nome = ";
idade =" ";
```

Neste caso estamos declarando duma variável chamada  **idade** do tipo inteiro e uma
outra variável chamada **nome** do tipo string.

### Atribuição de valores para as variáveis

```c#
a = 45;
t = ‘T’; 
valor = 200;
x = 98.80; 
sexo = ‘F’;
dia; // variável declarada e não inicializada
dia = 20; // variável atribuída agora
```

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="300px"/> | **Alerta de BSM:** *Sempre importante utilizar atenção aos detalhes nos detalhes de escrita para os tipos string e char precisa o valor estar entre "" * |
| ------------------------------------------------------------ | :----------------------------------------------------------- |

### Categorias de Variáveis

Existem três categorias de variáveis que podem ser declaradas em C# :


- Locais
- De instância
- De classe

Falaremos sobre esses três tipos de variáveis mais adiante neste documento, quando já
vermos apresentado os conceitos de orientação a objetos. Porém, vamos conceituá-
las de forma muito concisa a seguir, como uma introdução ao assunto:

**Variáveis Locais**

Podem ser utilizadas dentro do método onde foram declaradas, não sendo acessíveis de
outros pontos do programa.

**Variáveis de Instância**


Uma classe pode conter variáveis que são declaradas fora dos métodos, chamadas de
Variáveis de Instância. São usadas pelos objetos para armazenar seus estados.

Seus valores são específicos de cada instância e não são comparlhados entre as
instâncias.

**Variáveis de Classe**

Variáveis declaradas como estáticas são variáveis compartilhadas entre todos os objetos
instanciados a partir de uma classe. Por isso, essas variáveis também são conhecidas
como Variáveis de Classe.

### Constante

Uma constante é declarada quando precisamos lidar com dados que não devem ser
alterados durante a execução do programa. Para isso, utilizamos a palavra reservada
**const** para que a variável seja inicializada uma única vez.

Exemplos de declaração de constantes:

```c#

    const Pi = 3.14159;
    const SpeedOfLight = 300000; // km per sec.
    var radius = 5.3;
    var area = Constants.Pi * (radius * radius);
    var secsFromSun = 149476000 / Constants.SpeedOfLight; // in km
    Console.log(secsFromSun);

```

Por convenção, usamos letras maiúsculas para declarar constantes e assim disngui-las
das variáveis.

## Operadores

Para manipular os valores das variáveis de um programa, devemos ulizar os operadores
oferecidos pela linguagem de programação adotada. A linguagem C# possui diversos
operadores e os principais são categorizados da seguinte forma:

```c#
Aritméco(+, -, *, /, %) 

Atribuição(=, +=, -=, *=, /=, %=)

Relacional(==, !=, <, <=, >, >=)

Lógico(&&, ||)
```

Exemplos:

Operadores Aritméticos

```c#
var umMaisUm = 1 + 1; // umMaisUm = 2
var tresVezesDois = 3 * 2; // tresVezesDois = 6
var quatroDivididoPor2 = 4 / 2; // quatroDivididoPor2 = 2
var seisModuloCinco = 6 % 5; // seisModuloCinco = 1
var x = 7;


x = x + 1 * 2; // x = 9 7 x = x - 3; // x = 6 8
x = x / (6 - 2 + (3*5)/(16-1)); // x = 2
```

------

O módulo de um número x, na matemática, é o valor numérico de x
desconsiderando o seu sinal (valor absoluto). Na matemática expressamos o módulo
da seguinte forma: |−2|=2. Em linguagens de programação, o módulo de um número
é o resto da divisão desse número por outro. No exemplo acima, o resto da divisão
de 6 por 5 é iguala 1. Além disso, lemos a expressão 6%5 da seguinte forma: seis
módulo cinco.

------

Operadores de Atribuição

```c#
var valor = 1; // valor = 1

valor += 2; // valor = 3

valor -= 1; // valor = 2

valor *= 6; // valor = 12

valor /= 3; // valor = 4

valor %= 3; // valor = 1
```

Operadores Relacionais

```c#
var valor = 2;

var boolean t = false;
```

```c#
var t = (valor == 2); // t = true

var t = (valor != 2); // t = false

var t = (valor < 2); // t = false

var t = (valor <= 2); // t = true

var t = (valor > 1); // t = true

var t = (valor >= 1); // t = true
```

Operadores Lógicos

```c#
var valor = 30;
var teste = false;
```

```c#
var teste = valor < 40 && valor > 20; // teste = true
var teste = valor < 40 && valor > 30; // teste = false
var teste = valor > 30 || valor > 20; // teste = true
varteste = valor > 30 || valor < 20; // teste = false
varteste = valor < 50 && valor == 30; // teste = true
```

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="300px"/> | **Alerta de BSM:** *Sempre importante utilizar atenção aos detalhes nas diferença dos operadores lógicos ;* |
| ------------------------------------------------------------ | :----------------------------------------------------------- |


### Palavras reservadas

O C# faz uso de algumas palavras que não podem ser utilizadas, por exemplo, para
criar nome de variáveis, classes, métodos e etc... A seguir listamos algumas palavras
reservadas disponível no link abaixo:

https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/

### Estruturas de Controle if ( )...else

Quando queremos tomar uma decisão em nosso código, ou seja, definir outras opções
em C# utilizamos o comando if (se).
A sintaxe do if no C# é a seguinte

```c#
if (condicaoBooleana)
{ codigo; }
```
Uma condição booleana é qualquer expressão que retorne true ou false. Para isso, você
pode usar os operadores <, >, <=, >= e outros.
Além da utilização do if, nós poderemos utilizar a cláusula else (senão) para indicar o
comportamento que deve ser executado no caso da expressão booleana ser falsa.
Vejamos o exemplo abaixo para identificar essas duas cláusulas:

```c#
string nome = Console.ReadLine();
```
```
console.log("Nome: ");
var nome = console.log();
console.log("Peso: ");
var peso = Console.ReadLine();
console.log("Altura: ");
var altura = console.log();
var imc = peso / (altura * altura);
```

Em relação a este exemplo caso o seu IMC for maior ou igual a 40 irá aparecer duas
mensagens ( _“Obesidade grau III” e “Muito cuidado com o seu peso”_ ) atendendo a nossa
necessidade.
Mas caso o seu IMC for 34 além de apresentar a mensagem “ _Obesidade grau I_ ” irá
aparecer “ _Muito cuidado com o seu peso_ ” não atendendo a nossa necessidade.
Isso se deve ao fato de termos uma regra em relação as chaves de demarcação de cada
estrutura if( ). Só se torna obrigatório o uso das chaves { } quando ver mais de uma
linha de execução no bloco, quando ver apenas uma única linha de execução não se
torna necessário.
Nesse mesmo exemplo se quisermos colocar mais de uma opção dentro da condição
iremos ulizar os operadores lógicos, como no exemplo abaixo:

```c#
if (sexo == 'F' && imc < 19.1) {
console.log("Abaixo do peso."); 
}
else if (sexo == 'F' && imc <= 25.8) {
console.log("Peso ideal."); 
}
else if (sexo == 'F' && imc <= 27.3) {
console.log("Um pouco acima do peso."); 
}
else if (sexo == 'F' && imc <= 32.3) {
console.log("Acima do peso ideal.");
}
else if (sexo == 'F') { 
console.log("Obeso.");
}
else if (sexo == 'M' && imc < 20.7) {
console.log("Abaixo do peso.");
}
else if (sexo == 'M' && imc <= 26.4) {
console.log("Peso ideal.");
}
else if (sexo == 'M' && imc <= 27.8) {
console.log("Um pouco acima do peso.");
}
else if (sexo == 'M' && imc <= 31.1) {
console.log("Acima do peso ideal."); 
}
```
```c#
if (imc < 18.5)
console.log("Abaixo do peso ideal.");
else if (imc < 25)
console.log("Peso ideal.");
else if (imc < 30)
console.log("Acima do peso.");
else if (imc < 35)
console.log("Obesidade grau I.");
else if (imc < 40)
console.log("Obesidade grau II.");
else
console.log("Obesidade grau III.");
console.log("Muito cuidado com seu peso.");
```

```c#
else if (sexo == 'M') {
console.log("Obeso.");
}
```


```c#
teste = valor < 40 && valor > 20; // teste = true
teste = valor < 40 && valor > 30; // teste = false
teste = valor > 30 || valor > 20; // teste = true
teste = valor > 30 || valor < 20; // teste = false
teste = valor < 50 && valor == 30; // teste = true
```

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="300px"/> | **Alerta de BSM:** *Sempre importante utilizar atenção aos detalhes nas diferença dos operadores lógicos  maior e menor ;* |
| ------------------------------------------------------------ | :----------------------------------------------------------- |



O operador lógico && avalia as expressões do lado esquerdo e direito e retorna apenas
um resultado booleano. Para a expressão completa ser verdadeira, tanto o lado direito
como o lado esquerdo devem ser verdadeiras, mas para que a expressão completa seja
falsa, pelo menos um lado deve ser falso.

Ainda existe o operador lógico “OU”, representado por ||. Podemos ainda mudar o
código-fonte de nosso exemplo para usá-lo.

Veja que, usando o operador ||, conseguimos diminuir bastante a quantidade de linhas
de programação, porém deixamos as expressões booleanas dos ifs mais complexas, pois
agrupamos duas expressões que usam o operador && dentro de outra que usa o
operador ||.
O operador lógico || avalia as expressões dos dois lados e retorna um único resultado
booleano. Para que a expressão completa seja verdadeira, pelo menos um lado deve ser
verdadeiro.

### Estrutura de Controle switch( )

Sintaxe:

```
switch (Expressao){
case valor1: conjuntoDeSentencas;
break;
case valor2: SentencasAlternativas;
break;
case valor3: SentencasAlternativas2;
break;
case valor4: SentencasAlternativas3;
break;
}
```

O comando switch pode ter vários possíveis caminhos de decisão (casos). O primeiro
caso que estiver de acordo com o valor passado para o switch inicia a execução das
instruções do caso.
A sentença ‘break’ atrás de cada opção de case serve para que não avalie o resto de
opções e sim que saia diretamente do ‘Switch’, por isso, dependendo do que quiser
fazer, você colocará ou não.
Vamos verificar um exemplo para demonstrar a execução desse laço:

```c#
switch (i) {
case '1': console.log( "i contem um 1");
case '2': console.log( "i contem um 2");
case '3': console.log( "i contem um 3");
}
```
Exemplo usando o break:

```c#
var dia;
console.log("Digite um numero para encontrar o seu dia: ");
dia =  Console.ReadLine();
switch (dia) {
case 1:
 console.log("Domingo");
break;
case 2:
 console.log("Segunda");
break;
case 3:
 console.log("Terça");
break;
case 4:
 console.log("Quarta");
break;
case 5:
 console.log("Quinta");
break;
case 6:
 console.log("Sexta");
break;
 console.log("Sabado");
break;
default:
	console.log("Número digitado é inválido!!!");
break;
	}
}
```



## Estruturas de Repetição

Essas estruturas fazem com que uma instrução, ou bloco execute repetidamente,
enquanto uma expressão seja verdadeira.
Existem 2 tipos:
● Estruturas de repetição incondicional (simples): Repete um número específico de
vezes. Estrutura _for_
● Estruturas de repetição condicional: São estruturas de repetição que o controle é feito
pela avaliação de expressões condicionais. Ou seja, o número de repeções é
indeterminado na fase de programação, será conhecido durante a execução. Estruturas
_while_ e _do – while_

### Estrutura for ( )

```c#
for (inicialização; condição de execução; Incremento/decremento)
Bloco de Instruções;
```
● Inicialização: É usado para dar valor inicial a variável de controle (contador).
● Condição de execução: É uma expressão lógica que determina a execução associada
ao for, geralmente utilizando a variável de controle.
● Incremento/Decremento: Determina como a variável de controle (ou outras variáveis
também) será alterada a cada iteração do for.
● A inicialização é feita apenas antes da primeira iteração.
● A execução é encerrada quando a condição de execução for avaliada como falsa.
Exemplo:
Programa que soma os n primeiros números que entraram como argumento.

```c#
for (int i = 0; i < 3; i++)
{
    console.log(i);
}
// Output:
// 012soma+=i;
```



| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="300px"/> | **Alerta de BSM:** *Sempre importante utilizar atenção aos detalhes  na estrutura do laço de  repetição for. |
| ------------------------------------------------------------ | :----------------------------------------------------------- |



### Estrutura while ( )

O while é uma das formas de fazer loops (laços) em C# . Loops são usados para
executar um bloco de código diversas vezes, dependendo de uma condição ser
verdadeira.
O exemplo abaixo imprime todos os números em um intervalo informado pelo usuário.

```c#
int n = 0;
while (n < 5)
{
    console.log(n);
    n++;
}
// Output:
// 01234
```
O bloco de código dentro do while será executado enquanto o valor da variável
numeroAtual for menor ou igual ao valor da variável numeroFinal. Veja que usamos o
operador de incremento para adicionar à variável numeroAtual uma unidade a cada
execução do bloco de código do loop.

### Estrutura do...while( )

A declaração do-while é similar ao while. Ele executa a instrução pelo menos uma vez e
connua executando enquanto a expressão booleana for verdadeira.
Vejamos o exemplo abaixo:

```c#
int n = 0;
do
{
    console.log(n);
    n++;
} while (n < 5);
// Output:
// 01234
```



### Uma estrutura dentro da outra

Um bloco também pode ser declarado dentro de outro. Isto é, um if dentro de um for,
ou um for dentro de um for, algo como:

```
while (condicao) {
for (int i = 0; i < 10; i++) {
// código }
}
```


| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="300px"/> | **Alerta de BSM:** *Sempre importante utilizar Persistência e atenção aos detalhes quando estivermos codificando em C#* |
| ------------------------------------------------------------ | :----------------------------------------------------------- |





**Exemplo 02:** Queremos adiciona um novo Atributo/Coluna na  Tabela. Nesse caso executamos a seguinte query: 

## Arrays

Quando desejamos armazenar uma grande quantidade de valores de um determinado
tipo, podemos utilizar _arrays_. Um array é um objeto que pode armazenar muitos valores
de um determinado tipo.
Podemos imaginar um array como sendo um armário com um determinado número de
gavetas. E cada gaveta possui um rótulo com um número de identificação.

![enter image description here](https://i.imgur.com/w8gSnsN.png)

Para declarar um array devemos seguir a seguinte sintaxe:

**nome_do_array = [numero_de_elementos];**
Ou:
**nome_do_array = { valor1, valor2, ...,valorx};**

Por exemplo, se em uma sala de aula ver 20 alunos e você quiser declarar 20 variáveis
do tipo float usando array, ficaria assim:

**nota = [ 20 ];**
**nota = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 90. 1 , 10. 02 ,- 11 , 12. 9 , 13. 7 , 14. 5 , 15. 7 , 16. 0 , 17. 5 , 19. 3 , 20. 2 };**

E o nome dos alunos, armazenaríamos em strings:
**nome = [ 20 ];**

Se quisermos acessar os elementos de um array podemos fazer o seguinte:

```c#
var cars = ["Volvo", "BMW", "Ford", "Mazda"];
console.log(cars[0]);
// Outputs Volvo
```
E neste mesmo exemplo se quisermos alterar um elemento do array basta fazer o
seguinte:

```c#
var cars = ["Volvo", "BMW", "Ford", "Mazda"];
cars[0] = "Opel";
console.log(cars[0]);
```
Se quisermos saber o tamanho de um array iremos ulizar a propriedade length ( ).

```c#
arrayUm =[12, 3, 5, 68, 9, 6, 73, 44, 456, 65, 321] ;
arrayDois = [43, 42, 4, 8, 55, 21, 2, 45] ;

	if (arrayDois.length >8) {
		console.log("Tamanho do ArrayDois - Maior que 8!");
	} else {
		console.log("Tamanho do ArrayDois - Menor que 8!"``);
	}
	console.log("\nTamanho do ArrayUm = "+arrayUm.length);
	}
```
Para percorrer um array podemos ulizar um for-each:

```c#
cars = ["Volvo", "", "Ford", "Mazda"];
cars.forEach(element => {
    console.log(elements)
});
```

O exemplo acima pode ser lido assim: para cada string elemento (chamado i - como
em i NDEX) em carros , imprimir o valor de i.

Se você comparar o forloop e o loop for-each , verá que o método for -each é mais
fácil de escrever, não requer um contador (usando a propriedade length) e é mais legível.

### Arrays Multidimensionais

Os arrays bidimensionais precisam de dois índices para idenficar um elemento
parcular.

Por exemplo, quando um array é identificação dessa forma “numero [indiceA][indiceB]”, a
variável numero é o array, o indiceA é a linha e o indiceB é identificado como a coluna,
fazendo uma identificação de cada elemento no array por número de linha e coluna.

```c#
const mat = [ 
	[1, 2, 3], 
	[4, 5, 6], 
	[7, 8, 9] 
]; 

console.log(mat[0][0]);
```
## Funções em C#


Função é algo que deve ser feito uma ou várias vezes, sempre que for necessário para se
obter um resultado.

- Pode, ou não, receber parâmetros;

- Sempre retorna um resultado;

- Exemplos:

- Mostrar um menu e retornar a opção;

- Solicitar uma entrada ao usuário;

- Efetuar uma operação matemáca;

- Ler dados de um arquivo;

  

  A seguir podemos visualizar um exemplo de uma função chamada _MostraMenu_ que está
  sendo chamada pelo _main_.

```c#
using  System;
namespace  ExFuncao

{
	class  ExFuncao
	{
	static  void  Main(string[] args)

		{

		int opcao;

		do {

			opcao = MostrarMenu();

		   } while (opcao != 2);

		}

		public static int MostrarMenu(){
			string entrada;
			Console.WriteLine("==-MostrarMenu==");
			Console.WriteLine("1 Mostrar de novo");
			Console.WriteLine("2  - Sair");
			return entrada = Console.ReadLine();
		{

	}

}
```

Outro exemplo que podemos ulizar uma função é calcular os descontos percentuais
em valores de produtos.

- Precisa de quais dados?
- Precisa do valor atual do produto – double;
- Precisa do percentual de desconto – double;
- Resulta em algum novo dado?
- Sim, é uma função! O valor com desconto – double;


```c#
public static double calcDesc(double va, double pc) {
   double vd = va * (pc / 100); 
   return va - vd;
}
```


| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | **IMPORTANTE:** *Revisar o conteúdo de lógica de programação caso tiver alguma duvida lembre-se através da pratica temos a melhoria constante* |
| ------------------------------------------------------------ | ------------------------------------------------------------ |



## Orientação a Objetos

Programação Orientada a Objetos (POO) é um paradigma de programação que ajuda a
definir a estrutura de programas de computadores, baseado nos conceitos do mundo
real, sejam eles reais ou abstratos. A ideia é simular as coisas que existem e acontecem
no mundo real no mundo virtual.

### Classes e Objetos

Em C# os programas são escritos em pequenos pedaços separados, chamados de
objetos. Objetos são pequenos programas que guardam dentro de si os dados – em
suma, as variáveis – que precisam para executar suas tarefas. Os objetos também
trazem em si, como sub-rotinas, as instruções para processar esses dados. As variáveis
que um objeto guarda são chamadas de atributos, e as suas sub-rotinas são chamadas
de métodos.

Vamos colocar um exemplo bem simples para entender esses conceitos. Pensem em um
carro, este carro possui um motor, uma cor, portas, câmbio, etc. Ele também possui
comportamentos que, provavelmente, foram o movo de sua compra, como acelerar,
desacelerar, acender os faróis, buzinar e tocar música. Podemos dizer que o carro novo é
um _objeto_ , onde suas características são seus _atributos_ (dados atrelados ao objeto) e
seus comportamentos são ações ou _métodos_.
Ao mesmo tempo o seu carro, é apenas um dentre muitos outros dentro da loja, ou seja,
seu carro pode ser classificado como um carro que o seu carro será uma _instância_ dessa
classe chamada carro.

![enter image description here](https://i.imgur.com/QfO3hLI.png)


Podemos dar um outro exemplo em um domínio bancário:

![enter image description here](https://i.imgur.com/CXKDH3I.png)

Podemos representar uma classe através de diagramas UML.
![enter image description here](https://i.imgur.com/0ZswrCV.png)

Repare que a classe em si é um conceito abstrato, como um molde, que se torna
concreto e palpável através da criação de um objeto. Chamamos essa criação de
_instanciação da classe_ , como se estivéssemos usando esse molde (classe) para criar um
objeto.
Bem, visto os conceitos fundamentais de orientação à objetos, agora vamos aplicar
todos esses conceitos na prática utilizando a linguagem de programação C#.
Colocamos uma classe genérica _Pessoa_ , onde teria que guardar os vários pedaços do seu
nome, então para isso teríamos que criar alguns atributos para a mesma, por exemplo:


```c#
public class Pessoa {
	private string primeiroNome;
	private string ultimoNome;
	private string nomesDoMeio;
}
```

Criamos a classe Pessoa com três atributos, que será modelo para a criação de outros
objetos. Explicando melhor, então criamos três atributos do po private que serve para
deixar o atributo privado, ou seja, somente métodos da própria classe Pessoa que
poderá acessá-lo e manipular o mesmo.
Mas não basta criar os atributos, temos que também dar algumas funcionalidades para
os mesmos, para isso criamos um método para retornar o nome completo por exemplo.

```c#
public string getNomeCompleto() {
	string nomeCompleto = primeiroNome + " "  nomeDoMeio + " " + ultimoNome;
	return nomeCompleto;
}
```

A primeira linha, public string getNomeCompleto(), especifica o método. Primeiro,
declara-se, através da palavra-chave public, que o método é público – isto é, qualquer
método, de qualquer classe, pode invocá-lo. O método retorna objetos do tipo string e
se chama getNomeCompleto. O par de parênteses vazio significa que ele não recebe
parâmetro algum.

O conteúdo do método vem entre um par de chaves. Dentro do método, declara-se uma
nova variável, do tipo string, chamada nomeCompleto. Ao contrário de variáveis como
primeiroNome, nomeCompleto não é um atributo, mas sim uma _variável local_.
primeiroNome existirá desde a criação do objeto até sua retirada da memória, mas
nomeCompleto só existirá enquanto o método getNomeCompleto() estiver sendo
executado, e para cada chamada do método uma nova variável será criada.

A variável nomeCompleto recebe o resultado da concatenação de string. O sinal de
atribuição é =, e a concatenação de string é feita através do operador +. Ao final, um
ponto-e-vírgula sinaliza o fim deste comando. Abaixo, temos o comando return. Quando
ele é invocado, o método termina e o valor que está à sua frente (no caso, o valor
referenciado pela variável nomeCompleto) é retornado.
Até agora ainda não construímos nenhum objeto, para isto C# tem uma ferramenta


chamada _construtor_. Geralmente os construtores tem o mesmo nome da classe. Esse
construtor cria um novo objeto e este novo objeto é armazenado na variável _pessoa_.

```
Pessoa pessoa = new Pessoa();
```
Agora vamos criar uma pessoa chamada Francisco Pinho Nunes.

```c#
public class ProgramaNome {
	public static void main(String[] args) {
		Pessoa pessoa = new Pessoa();
		pessoa.primeiroNome = “Francisco”;
		pessoa.nomeDoMeio = “Pinho”;
		pessoa.ultimoNome = “Nunes”;
		Console.WriteLine(pessoa.getNomeCompleto());
	}
}
```
No entanto, isto não é possível porque os atributos são privados. Apenas os métodos da
classe _Pessoa_ podem acessá-los. Isso pode ser solucionado de várias maneiras, e uma
das mais elegantes é criando o nosso próprio construtor, como abaixo:

```c#
public string Pessoa(string primeiro, string meio, string ultimo ) {
    primeiroNome = primeiro;
    ultimoNome = ultimo;
    nomeDoMeio = meio;
}
```

A declaração do construtor é sempre o nome da classe seguido pela lista de parâmetros.
A palavra _public_ indica que o construtor é público, de modo que pode ser invocado por
qualquer classe. Um ponto importante sobre construtores é que eles não criam nem
retornam objetos; quem faz isso é a palavra reservada _new_. O construtor apenas
executa algum procedimento sobre o objeto criado pelo comando _new_. Este construtor,
no caso, recebe os nomes como parâmetros e os atribui aos atributos.

Agora, podemos trocar as quatro primeiras linhas do método _main()_ inválido por apenas
a seguinte:

```
Pessoa pessoa = new Pessoa( "Francisco", "Pinho", "Nunes" );
```

Só para idenficar, vejamos como ficou a classe _Pessoa_ completa:

```c#
using  System;
namespace  Pessoa

{
	class  Pessoa
	{
		private string primeiroNome;
		private string nomeDoMeio;
		private string ultimoNome;

		public string Pessoa(string primeiro, string meio, string ultimo ) {
    		primeiroNome = primeiro;
    		ultimoNome = ultimo;
    		nomeDoMeio = meio;
		}

		public string getNomeCompleto() {
			string nomeCompleto = primeiroNome + " "  nomeDoMeio + " " + ultimoNome;
			return nomeCompleto;
		}

	}

}
```

E a classe ProgramaNome, que utiliza a classe Pessoa para gerar um nome completo a
partir das partes.

```c#
public class ProgramaNome {
public static void main(String[] args) {
Pessoa pessoa = new Pessoa("Francisco","Pinho","Nunes");
Console.WriteLine(pessoa.getNomeCompleto());
} }
```
### Objeto this

A palavra reservada _this_ faz referência ao próprio objeto, quando usado dentro de um
método, por exemplo.
No código-fonte da classe Aeronave, vamos criar um método chamado
alterarTotalAssentos, que receberá um argumento com o novo número de passageiros a
ser atribuído à variável de instância totalAssentos.

```
class Aeronave {
int totalAssentos;
int assentosReservados;

void reservarAssentos(int assentos) {
assentosReservados += assentos;
}

int calcularAssentosDisponiveis() {
return totalAssentos - assentosReservados;
}

void alterarTotalAssentos(int totalAssentos) {
this.totalAssentos = totalAssentos;
}
```

Estamos dizendo que queremos atribuir o valor da variável local à variável de instância.
Quando usamos _this_ , estamos deixando essa informação explícita.

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="300px"/> | **Alerta de BSM:** *Sempre importante utilizar a comunicação para a leitura dos materias e para perguntar para o instrutor caso tenha duvida* |
| ------------------------------------------------------------ | :----------------------------------------------------------- |



### Encapsulamento

Vamos voltar ao exemplo que demos do carro:
![enter image description here](https://i.imgur.com/xWH5fA8.png)
Os métodos do carro, como acelerar, podem usar atributos e outros métodos do carro
como o tanque de gasolina e o mecanismo de injeção de combustível, respectivamente,
uma vez que acelerar gasta combustível.
Mas alguns métodos e atributos não podem ser permitidos qualquer tipo de alteração,
ou seja, eles não são visíveis para fora do carro.
Na POO, um atributo ou método que não é visível de fora do próprio objeto é chamado
de “ _privado_ ” e quando é visível, é chamado de “ _público_ ”.


![enter image description here](https://i.imgur.com/4pwtSG5.png)

Ler ou alterar um atributo encapsulado pode ser feito a partir de _geters e seters_ (colocar
referência).
Esse _encapsulamento_ de atributos e métodos impede o chamado _vazamento de escopo_ ,
onde um atributo ou método é visível por alguém que não deveria vê-lo, como outro
objeto ou classe. Isso evita a confusão do uso de variáveis globais no programa,
deixando mais fácil de idenficar em qual estado cada variável vai estar a cada momento
do programa, já que a restrição de acesso nos permite idenficar quem consegue
modificá-la.
Exemplo:

```c#
public class Carro {
    
private double velocidade;
private string modelo;
private MecanismoAceleracao mecanismoAceleracao;
private string cor;
    
/* Repare que o mecanismo de aceleração é inserido no carro ao ser construí
public Carro(String modelo, MecanismoAceleracao mecanismoAceleracao) {
	this.modelo = modelo;
	this.mecanismoAceleracao = mecanismoAceleracao; this.velocidade = 0; }
public void acelerar() {
	this.mecanismoAceleracao.acelerar(); }
public void frear() { /* código do carro para frear */ }

public void acenderFarol() { /* código do carro para acender o farol */ }

public Double getVelocidade() { return this.velocidade }

private void setVelocidade() {
/* código para alterar a velocidade do carro */ /* Como só o próprio carro*/
    
}

public String getModelo() { return this.modelo; }

public String getCor() { return this.cor; }
/* podemos mudar a cor do carro quando quisermos */
    
public void setCor(String cor) { this.cor = cor; }
    
}
```
### Herança

![enter image description here](https://i.imgur.com/tQoUQij.png)

Quando dizemos que uma classe A _é um tipo de_ classe B, dizemos que a classe A _herda_
as características da classe B e que a classe B é _mãe_ da classe A, estabelecendo então
uma relação de herança entre elas.
Neste caso, por exemplo, o cachorro, herdará todas as características do mamífero e o
mamífero herda as características de um animal.
Por exemplo, poderíamos ter uma classe Animal que representasse animais em geral e
as atividades que todos eles executam. Uma dessas atividades é comer, e nossa classe
poderia ser como a abaixo.

```c#
public class Animal {
	public void comer(String alimento) {
		Console.WriteLine("Eu estou comendo "+alimento);
	}
}
```
Uma classe de mamíferos _estenderia_ a classe de animais, porque mamíferos podem fazer
coisas que outros animais não podem – por exemplo, gerar leite. Uma classe Mamifero
estenderia a classe _Animal_ usando a sinal **:** em sua declaração:

```c#
public class Mamifero:Animal {
}
```
Um novo método, _lactar()_ , também poderia ser adicionado:

```c#
public String lactar() {
return "leite" ;
}
```
Como mamíferos são animais, também precisam do método _comer()_ , e aí entra uma das
vantagens da herança: como a classe Mamífero estende a classe Animal, ela _herda_ todos
os métodos de Animal, então não é preciso reescrevê-los.

```c#
public class AnimaisAcao {
	public static void main(string[] args) {
		Animal animal = new Animal();`
		Mamifero mamifero = new Mamifero();
		animal.comer (" plantas ");
		mamifero.comer (" queijo ");
		string produto = mamifero.lactar();
		Console.WriteLine("O produto da lactação é "+ produto);
	}
}
```
O programa acima representa bem isso: note como o método comer() é invocado,
mesmo sem ser declarado em Mamífero.

A figura abaixo mostra a impressão deste programa:

![enter image description here](https://i.imgur.com/ZGg7eHY.png)



| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="300px"/> | **Alerta de BSM:** *Sempre importante utilizar atenção aos detalhes no sinal de : para herança em C#* |
| ------------------------------------------------------------ | :----------------------------------------------------------- |





### Sobrescrita de métodos

Uma classe pode ter dois ou mais métodos com o mesmo nome, desde que os tipos de
seus argumentos sejam distintos.
Isso é útil quando queremos implementar um método em função de outro.
Então falamos que sobrecarga de métodos é um conceito simples da orientação a
objetos, que permite a criação de vários métodos com o mesmo nome, mas com
parâmetros diferentes.
Para exemplifica vamos pegar uma classe Aeronave que irá permitir reservar os assentos
normais e os especiais.

Agora vamos sobrecarregar o método reservarAssentos , incluindo uma nova versão com
parâmetros adicionais:

```c#
void reservarAssentos(int assentosNormais, int assentosEspeciais) {
	this.assentosNormaisReservados += assentosNormais;
	this.assentosEspeciaisReservados += assentosEspeciais;
}
```
```c#
class Aeronave {
	int totalAssentosNormais;
	int totalAssentosEspeciais;
	int assentosNormaisReservados;
	int assentosEspeciaisReservados;
    
void reservarAssentos(int assentos) { this.assentosNormaisReservados += ass
}
    
int calcularAssentosDisponiveis() {
	return totalAssentosNormais - assentosNormaisReservados + totalAssentosEspe
}
```


O método acima recebe, além do número de assentos normais, o total de assentos
especiais a serem reservados. Isso é sobrecarga de métodos! Temos duas versões de
métodos com o nome _reservarAssentos_. Vamos ver as assinaturas desses métodos?

```c#
void reservarAssentos(int)
void reservarAssentos(int, int)
```
Sobrecarga de métodos é algo simples de ser feito, mas tem uma restrição que a própria
linguagem impõe. Não é possível ter duas versões de métodos com a mesma assinatura.
Por exemplo, seria impossível ter o método a seguir na _classeAeronave_ :

```c#
void reservarAssentos(int assentosEspeciais) {
this.assentosEspeciaisReservados += assentosEspeciais;
}
```
O código acima seria uma tentava de criar uma versão do método _reservarAssentos_ ,
para reservar assentos especiais, mas não funcionaria (nem compilaria), porque a classe
Aeronave já possui um método _reservarAssentos_ que recebe um int.



### Interface

Quando duas (ou mais) classes possuem comportamentos comuns que podem ser
separados em uma outra classe, dizemos que a “classe comum” é uma _interface_ , que
pode ser “herdada” pelas outras classes. Note que colocamos a interface como “classe
comum”, que pode ser “herdada” (com aspas), porque uma interface não é exatamente
um classe, mas sim um conjunto de métodos que todas as classes que herdarem dela
devem possuir (implementar) - portanto, uma interface não é “herdada” por uma classe,
mas sim _implementada_. No mundo do desenvolvimento de software, dizemos que uma
interface é um “contrato”: uma classe que implementa uma interface deve fornecer uma
implementação a todos os métodos que a interface define, e em compensação, a classe
implementadora pode dizer que ela é do tipo da interface.

Abaixo é possível ver um exemplo de uma interface chamada FiguraGeometrica_ com três
assinaturas de métodos que virão a ser implementados pelas classes referentes às
figuras geométricas.

```c#
using  System;
namespace  Pessoa

{
	public  interface FiguraGeometrica
    {
        
        public string getNomeFigura();
        public int getArea();
        public int getPerimetro();

    }  
	
}
```

Para realizar a chamada/referência a uma interface por uma determinada classe, é
necessário adicionar o sinal **:** ao final da assinatura da classe que irá
implementar a interface escolhida.

Sintaxe:
**public class nome_classe : nome_interface**

Onde:

```c#
nome_classe – Nome da classe a ser implementada.
nome_Interface – Nome da interface a se implementada pela classe.
```
Abaixo é possível ver duas classes que implementam a interface FiguraGeometrica, uma
chamada Quadrado e outra Triangulo.

Classe Quadrado

```c#
/*
@author Robson Fernando Gomes
*/
public class Quadrado : FiguraGeometrica {
	private int lado;
	public int getLado() {
	return lado;
}
public void setLado(int lado) {
	this.lado = lado;
}


public override int getArea() {
	int area = 0;
	area = lado * lado;
	return area;
}

public override  int getPerimetro() {
	int perimetro = 0;
	perimetro = lado * 4;
	return perimetro;
}
public override  string getNomeFigura() {
	return "quadrado";
	}
}
```
Classe Triangulo

```c#
public class Triangulo : FiguraGeometrica {

	private int base;
	private int altura;
	private int ladoA;
	private int ladoB;
	private int ladoC;

public int getAltura() {
	return altura;
}

public void setAltura(int altura) {
	this.altura = altura;
}

public int getBase() {
	return base;
}

public void setBase(int base) {
	this.base = base;
}

public int getLadoA() {
	return ladoA;
}

public void setLadoA(int ladoA) {
	this.ladoA = ladoA;
}

public int getLadoB() {
	return ladoB;
}

public void setLadoB(int ladoB) {
	this.ladoB = ladoB;
}

public int getLadoC() {
	return ladoC;
}

public void setLadoC(int ladoC) {
	this.ladoC = ladoC;
}


public override string getNomeFigura() {
	return "Triangulo";
}


public override int getArea() {
	int area = 0;
	area = (base * altura) / 2;
	return area;
}

public override int getPerimetro() {
	int perimetro = 0;
	perimetro = ladoA + ladoB + ladoC;
		return perimetro;
	}
}
```
| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="300px"/> | **Alerta de BSM:** *Sempre importante utilizar atenção aos detalhes no sinal de : para implementar interfaces em C#* |
| ------------------------------------------------------------ | :----------------------------------------------------------- |



Como é possível ver acima, ambas as classes seguiram o contrato da interface
_FiguraGeometrica_ , porém cada uma delas a implementou de maneira diferente.

Ao contrário da herança que limita uma classe a herdar somente uma classe pai por vez,
é possível que uma classe implemente varias interfaces ao mesmo tempo.

## Polimorfismo


Polimorfismo é a capacidade de um objeto poder ser referenciado de várias formas.
(cuidado, polimorfismo não quer dizer que o objeto fica se transformando, muito pelo
contrário, um objeto nasce de um po e morre daquele po, o que pode mudar é a
maneira como nos referimos a ele).
Se você tem uma _class Animal_ sabe que todo animal come, sendo que Cães por exemplo
comem ração e Tigres carne. Você pode chamar o método comer nessas 2 classes
mesmo sabendo que elas se comportam diferentemente.

```c#
public class Animal {
	public void comer() {
		Console.WriteLine( "Animal Comendo..." );
	}
}

public class Cao : Animal {
	public void comer() {
	Console.WriteLine( "Cão Comendo..." );
	}
}
public class Tigre : Animal {
	public void comer() {
	Console.WriteLine( "Tirgre Comendo..." );
	}
}
```


No caso a sua chamado de método polimórfico ficaria assim:

```c#
public class Test {
	public void fazerAnimalComer( Animal animal ) {
	animal.comer();
}
public static void main( string[] args ) {
	Test t = new Test();
	t.fazerAnimalComer( new Animal() );
	t.fazerAnimalComer( new Cao() );
	t.fazerAnimalComer( new Trigre() );
	}
}
```
Você vai notar que cada chamada vai fazer uma coisa diferente, porém como existe
herança entre as classes todos os métodos vão funcionar, porque são do tipo do mais
genérico (Animal) ou são filhos do mais genérico.



| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | **IMPORTANTE:** *Revisar o conteúdo de programação orientada a objeto caso tiver alguma duvida, lembre-se através da pratica temos a melhoria constante* |
| ------------------------------------------------------------ | ------------------------------------------------------------ |




## Exceptions

O uso de exceções permite separar a detecção da ocorrência de uma situação
excepcional do seu tratamento, ao se programar um método em C#.
Alguns possíveis movos externos para ocorrer uma exceção são:

```
Tentar abrir um arquivo que não existe.
Tentar fazer consulta a um banco de dados que não está disponível.
Tentar escrever algo em um arquivo sobre o qual não se tem permissão de escrita.
Tentar conectar em servidor inexistente.
```
Alguns possíveis erros de lógica para ocorrer uma exceção são:

```
Tentar manipular um objeto que está com o valor nulo.
Dividir um número por zero.
Tentar manipular um po de dado como se fosse outro.
Tentar ulizar um método ou classe não existentes.
```
Para tratar as exceções em C# são utilizamos os comandos try e catch.
Praticamente, o uso dos blocos try/catch se dá em métodos que envolvem alguma
manipulação de dados, bem como:

```
CRUD no banco de dados;
Índices fora do intervalo de array;
Cálculos matemácos;
I/O de dados;
Erros de rede;
Anulação de objetos;
Entre outros;
Exemplo da ulização do bloco try/catch:
```

```c#
public stac void main(String args[])
{
	string frase = null;
	string novaFrase = null;
try
{
	novaFrase = frase.toUpperCase();
}
catch (InvalidCastException  e) //CAPTURA DA POSSÍVEL exceção.
{
	//TRATAMENTO DA exceção
	Console.WriteLine(“O frase inicial está nula,
	para solucional tal o problema, foi lhe atribuito um valor default.”);
	frase = “Frase vazia”;
	novaFrase = frase.toUpperCase();
}
	Console.WriteLine("Frase anga: "+frase);
	Console.WriteLine("Frase nova: "+novaFrase);
}
/*Quando este código for executado, o mesmo lançará uma NullPointerExcepon,
porém esta exceção será tratada desta vez, sendo a mesma capturada pelo catch{}
e dentro deste bloco as devidas providências são tomadas. Neste caso é atribuído
um valor default à variável frase.*/
```


### Estrutura try-catch-finally

Como vimos anteriormente, usamos try-catch para tratar uma exceção. A terceira parte
dessa estrutura, finally, especifica um trecho de código que será sempre executado, não
importando o que acontecer dentro do bloco try-catch.
Não é possível deixar um bloco try-catch-finally sem executar sua parte finally.
Vejamos um exemplo para este bloco:

```c#
void readFile(string name) throws IOException {
	FileStream  file = null;
	try { file = new FileStream(name); ... // lê o arquivo }
	catch (Exception e)
		{ Console.WriteLine(e); }
	finally {
		if (file != null)
		file.close(); } }
```
### Comandos throw e throws

As cláusulas throw e throws podem ser entendidas como ações que propagam
exceções, ou seja, em alguns momentos existem exceções que não podem ser tratadas
no mesmo método que gerou a exceção. Nesses casos, é necessário propagar a exceção
para um nível acima na pilha.

```c#
static int GetValueFromArray(int[] array, int index)
{
    try
    {
        return array[index];
    }
    catch (IndexOutOfRangeException ex)
    {
        throw new ArgumentException("Index is out of range", nameof(index), ex);
    }
}
```


## Collections

A coleção em C# é uma estrutura que fornece uma arquitetura para armazenar e
manipular o grupo de objetos.

Para muitos aplicativos, você desejará criar e gerenciar grupos de objetos relacionados. Há duas maneiras de agrupar objetos: criando matrizes de objetos e criando coleções de objetos.

As matrizes são mais úteis para criar e trabalhar com um número fixo de objetos fortemente tipados. Para obter informações sobre matrizes, consulte [Matrizes](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/arrays/).

As coleções fornecem uma maneira mais flexível de trabalhar com grupos de objetos. Ao contrário das matrizes, o grupo de objetos com o qual você trabalha pode crescer e reduzir dinamicamente conforme as necessidades do aplicativo são alteradas. Para algumas coleções, você pode atribuir uma chave para qualquer objeto que coloque na coleção para que você possa recuperar rapidamente o objeto usando a chave.

Uma coleção é uma classe, portanto você deve declarar uma instância da classe antes de adicionar elementos a essa coleção.

Se a coleção contiver elementos de apenas um tipo de dados, você poderá usar uma das classes no namespace [System.Collections.Generic](https://docs.microsoft.com/pt-br/dotnet/api/system.collections.generic). Uma coleção genérica impõe segurança de tipos para que nenhum outro tipo de dados possa ser adicionado a ela. Ao recuperar um elemento de uma coleção genérica, você não precisa determinar seu tipo de dados ou convertê-lo.


### List

Os exemplos nesta seção usam a classe genérica [List](https://docs.microsoft.com/pt-br/dotnet/api/system.collections.generic.list-1), que habilita você a trabalhar com uma lista de objetos fortemente tipados.

O exemplo a seguir cria uma lista de cadeias de caracteres e, em seguida, itera nas cadeias de caracteres usando uma instrução [foreach](https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement).

```c#
c// Create a list of strings.
var salmons = new List<string>();
salmons.Add("chinook");
salmons.Add("coho");
salmons.Add("pink");
salmons.Add("sockeye");

// Iterate through the list.
foreach (var salmon in salmons)
{
    Console.Write(salmon + " ");
}
// Output: chinook coho pink sockeye
```


Se o conteúdo de uma coleção for conhecido com antecedência, você poderá usar um *inicializador de coleção* para inicializar a coleção. Para obter mais informações, consulte [Inicializadores de coleção e objeto](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers).

O exemplo a seguir é igual ao exemplo anterior, exceto que um inicializador de coleção é usado para adicionar elementos à coleção.



```c#
// Create a list of strings by using a
// collection initializer.
var salmons = new List<string> { "chinook", "coho", "pink", "sockeye" };

// Iterate through the list.
foreach (var salmon in salmons)
{
    Console.Write(salmon + " ");
}
// Output: chinook coho pink sockeye
```
Você pode usar uma instrução [for](https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement) em vez de uma instrução `foreach` para iterar em uma coleção. Você realiza isso acessando os elementos da coleção pela posição do índice. O índice dos elementos começa em 0 e termina na contagem de elementos, menos de 1

O exemplo a seguir itera nos elementos de uma coleção usando `for` em vez de `foreach`.

```c#
// Create a list of strings by using a
// collection initializer.
var salmons = new List<string> { "chinook", "coho", "pink", "sockeye" };

for (var index = 0; index < salmons.Count; index++)
{
    Console.Write(salmons[index] + " ");
}
// Output: chinook coho pink sockeye
```

O exemplo a seguir remove um elemento da coleção, especificando o objeto a ser removido.

```c#
// Create a list of strings by using a
// collection initializer.
var salmons = new List<string> { "chinook", "coho", "pink", "sockeye" };

// Remove an element from the list by specifying
// the object.
salmons.Remove("coho");

// Iterate through the list.
foreach (var salmon in salmons)
{
    Console.Write(salmon + " ");
}
// Output: chinook pink sockeye
```

O exemplo a seguir remove elementos de uma lista genérica. Em vez de `foreach` uma instrução , `for` uma instrução que itera em ordem decrescente é usada. Isso é feito porque o método [RemoveAt](https://docs.microsoft.com/pt-br/dotnet/api/system.collections.generic.list-1.removeat) faz com que os elementos após um elemento removido tenham um valor de índice menor.

```
var numbers = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

// Remove odd numbers.
for (var index = numbers.Count - 1; index >= 0; index--)
{
    if (numbers[index] % 2 == 1)
    {
        // Remove the element by specifying
        // the zero-based index in the list.
        numbers.RemoveAt(index);
    }
}

// Iterate through the list.
// A lambda expression is placed in the ForEach method
// of the List(T) object.
numbers.ForEach(
    number => Console.Write(number + " "));
// Output: 0 2 4 6 8
```

Para o tipo dos elementos na [List](https://docs.microsoft.com/pt-br/dotnet/api/system.collections.generic.list-1), você também pode definir sua própria classe. No exemplo a seguir, a classe `Galaxy` que é usada pela [List](https://docs.microsoft.com/pt-br/dotnet/api/system.collections.generic.list-1) é definida no código.

```c#
private static void IterateThroughList()
{
    var theGalaxies = new List<Galaxy>
        {
            new Galaxy() { Name="Tadpole", MegaLightYears=400},
            new Galaxy() { Name="Pinwheel", MegaLightYears=25},
            new Galaxy() { Name="Milky Way", MegaLightYears=0},
            new Galaxy() { Name="Andromeda", MegaLightYears=3}
        };

    foreach (Galaxy theGalaxy in theGalaxies)
    {
        Console.WriteLine(theGalaxy.Name + "  " + theGalaxy.MegaLightYears);
    }

    // Output:
    //  Tadpole  400
    //  Pinwheel  25
    //  Milky Way  0
    //  Andromeda  3
}

public class Galaxy
{
    public string Name { get; set; }
    public int MegaLightYears { get; set; }
}
```



```c#
public class Triangulo : FiguraGeometrica {

	private int base;
	private int altura;
	private int ladoA;
	private int ladoB;
	private int ladoC;

public int getAltura() {
	return altura;
}

public void setAltura(int altura) {
	this.altura = altura;
}

public int getBase() {
	return base;
}

public void setBase(int base) {
	this.base = base;
}

public int getLadoA() {
	return ladoA;
}

public void setLadoA(int ladoA) {
	this.ladoA = ladoA;
}

public int getLadoB() {
	return ladoB;
}

public void setLadoB(int ladoB) {
	this.ladoB = ladoB;
}

public int getLadoC() {
	return ladoC;
}

public void setLadoC(int ladoC) {
	this.ladoC = ladoC;
}


public override string getNomeFigura() {
	return "Triangulo";
}


public override int getArea() {
	int area = 0;
	area = (base * altura) / 2;
	return area;
}

public override int getPerimetro() {
	int perimetro = 0;
	perimetro = ladoA + ladoB + ladoC;
		return perimetro;
	}
}
```

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="300px"/> | **Alerta de BSM:** *Sempre importante utilizar atenção aos detalhes nos metodos de inclusão de dados Add() e exclusão Remove() das List* |
| ------------------------------------------------------------ | :----------------------------------------------------------- |



## Estrutura forEach

A instrução executa uma instrução ou um bloco de instruções para cada elemento em uma instância do tipo que implementa a interface ou , como mostra o `foreach` exemplo a [System.Collections.IEnumerable](https://docs.microsoft.com/pt-br/dotnet/api/system.collections.ienumerable) [System.Collections.Generic.IEnumerable](https://docs.microsoft.com/pt-br/dotnet/api/system.collections.generic.ienumerable-1) seguir:

```
var fibNumbers = new List<int> { 0, 1, 1, 2, 3, 5, 8, 13 };
foreach (int element in fibNumbers)
{
    Console.Write($"{element} ");
}
// Output:
// 0 1 1 2 3 5 8 13
```

A `foreach` instrução não está limitada a esses tipos. Você pode usá-lo com uma instância de qualquer tipo que atenda às seguintes condições:

- Um tipo tem o método público sem `GetEnumerator` parâmetros. A partir do C# 9.0, o `GetEnumerator` método pode ser o método de extensão de um [tipo](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/extension-methods).
- O tipo de retorno do `GetEnumerator` método tem a propriedade pública e o método público sem `Current` `MoveNext` parâmetros cujo tipo de retorno é `bool` .



### Lambda expression

Uma expressão Lambda é uma função anônima que você pode usar para criar delegados ou tipos de árvore de expressão. Ao usar expressões lambda, você pode escrever funções locais que podem ser passadas como argumentos ou retornadas como o valor de chamadas de função. 

## Como criar um expressão lambda?

Para criar uma expressão lambda, especifique os parâmetros de entrada (se houver) no lado esquerdo do operador lambda =>, e coloque a expressão ou o bloco de instruções do outro lado.

Por exemplo, a expressão lambda **x => x \* x** especifica um parâmetro chamado “**x**” e retorna o valor de **x** **ao quadrado**.

Você pode atribuir essa expressão a um tipo delegate da seguinte forma:

```c#
delegate int delegado(int i);  

static void Main(string[] args)  
{  
    delegado meuDelegate = x => x * x;  
    int valor = meuDelegate(5);  
}
```

## Var variáveis locais de tipo implícito


Variáveis locais podem ser declaradas sem fornecer um tipo explícito. A palavra-chave `var` instrui o compilador a inferir o tipo da variável da expressão no lado direito da instrução de inicialização. O tipo inferido pode ser um tipo integrado, um tipo anônimo, um tipo definido pelo usuário ou um tipo definido na biblioteca de classes do .NET. Para obter mais informações sobre como inicializar matrizes com `var`, consulte [Matrizes de tipo implícito](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/arrays/implicitly-typed-arrays).

Os exemplos a seguir mostram várias maneiras em que as variáveis locais podem ser declaradas com `var`:

```c#
// i is compiled as an int
var i = 5;

// s is compiled as a string
var s = "Hello";

// a is compiled as int[]
var a = new[] { 0, 1, 2 };

// expr is compiled as IEnumerable<Customer>
// or perhaps IQueryable<Customer>
var expr =
    from c in customers
    where c.City == "London"
    select c;

// anon is compiled as an anonymous type
var anon = new { Name = "Terry", Age = 34 };

// list is compiled as List<int>
var list = new List<int>();
```

É importante entender que a palavra-chave `var` não significa "variante" e não indica que a variável é vagamente tipada ou de associação tardia. Isso apenas significa que o compilador determina e atribui o tipo mais apropriado.



## DateTime 

Obtém o componente de data da instância.

```c#
public DateTime Date { get; }
```

####  Valor da propriedade

- [DateTime](https://docs.microsoft.com/pt-br/dotnet/api/system.datetime?view=net-6.0)

Um novo objeto com a mesma data que essa instância e o valor temporal definido como meia-noite em 12:00:00 (00:00:00).

## Exemplos

O exemplo a seguir usa a [Date](https://docs.microsoft.com/pt-br/dotnet/api/system.datetime.date?view=net-6.0) propriedade para extrair o componente de data de um [DateTime](https://docs.microsoft.com/pt-br/dotnet/api/system.datetime?view=net-6.0) valor com seu componente de tempo definido como zero (ou 0:00:00, ou meia-noite). Ele também ilustra que, dependendo da cadeia de caracteres de formato usada ao exibir o [DateTime](https://docs.microsoft.com/pt-br/dotnet/api/system.datetime?view=net-6.0) valor, o componente de tempo pode continuar a aparecer na saída formatada.

```c#
using System;

public class Example
{
   public static void Main()
   {
      DateTime date1 = new DateTime(2008, 6, 1, 7, 47, 0);
      Console.WriteLine(date1.ToString());

      // Get date-only portion of date, without its time.
      DateTime dateOnly = date1.Date;
      // Display date using short date string.
      Console.WriteLine(dateOnly.ToString("d"));
      // Display date using 24-hour clock.
      Console.WriteLine(dateOnly.ToString("g"));
      Console.WriteLine(dateOnly.ToString("MM/dd/yyyy HH:mm"));
   }
}
// The example displays output like the following output:
//       6/1/2008 7:47:00 AM
//       6/1/2008
//       6/1/2008 12:00 AM
//       06/01/2008 00:00
```

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="300px"/> | **Alerta de BSM:** *Sempre importante utilizar atenção aos detalhes no formato de data do DateTime |
| ------------------------------------------------------------ | :----------------------------------------------------------- |



### Vamos trabalhar com o Now

Vamos utilizar a função **Now** do Datetime, que pega a data e hora atual do seu sistema operacional, com isto ele faz a atribuição do horário para variável de maneira automática.

E como definimos para pegar a formatação do Brasil, não precisamos nos preocupar como vai vir a data e nem se ela será digitada errada.

```c#
DateTime dataEntrada = DateTime.Now;

Console.WriteLine(dataEntrada);
```

Nosso valor de saída vai ser a hora atual do meu sistema.

```

01/05/2019 14:20:11
```

# Métodos da Classe String

A classe **String**, do namespace System do **.NET Framework** é muito útil, provavelmente todos os desenvolvedores já utilizaram ao menos um método muito conhecido que retornar um objeto desse tipo, o **ToString()**

### String.Format

Começando pelos métodos com membros estáticos, vamos falar do **Format**. Este método é uma mão na roda para os desenvolvedores que desejam formatar seus textos sem muitas preocupações, de uma forma rápida e simples.

```c#
private void btnExibir_Click(object sender, EventArgs e) {
	txtTexto.Text = String.Format("Posso incluir o número {0}, {1} e {2} aqui!",
					10, 20, 30);
}
```

### String.IsNullOrEmpty

O outro método com membro estático que iremos falar é o **IsNullOrEmpty**, muito útil para validar se o valor de um TextBox é nulo ou vazio. Na **Listagem 2** vemos um exemplo com este método.

**Listagem 2:** Método IsNullOrEmpty em ação

```c#
if (String.IsNullOrEmpty(txtTexto.Text))
{
	Console.WriteLine("Campo vazio!");
}
```

### Contains

Este método é parecido com o operador [LIKE](http://www.devmedia.com.br/sql-select-guia-para-iniciantes/29530), da linguagem SQL. Sua função é verificar se uma determinada string contém o valor informado em seu parâmetro.

Veja na Listagem 3 um exemplo em que se busca a palavra String e, se achar, é exibida uma mensagem para usuário.

**Listagem 3:** Busca por parte de uma string com o método Contains

```c#
if (txtTexto.Text.Contains("String"))
{
	Console.WriteLine("Você digitou String!");
}
```

### Substring

Com este método conseguimos recuperar partes de uma string, apenas informando o índice de início (em uma das sobrecargas), semelhante a como foi feito com o método Remove. Veja como pegar trechos de uma frase qualquer, na **Listagem 7** e o resultado na **Figura 6**.

**Listagem 7:** Recuperando partes de uma string

```c#
Console.WriteLine(txtTexto.Text.Substring(6));
```

### ToLower

Com este método conseguimos converter qualquer string para letras minúsculas. Veja como é bem simples seu uso, na **Listagem 8** e o resultado na **Figura 7**.

**Listagem 8:** Fazendo a string ficar minúscula

```c#
Console.WriteLine(txtTexto.Text.ToLower());
```

### ToUpper

Função oposta ao método ToLower, que faz toda a string ficar maiúscula. Veja o exemplo na **Listagem 9** e o resultado na **Figura 8**.

**Listagem 9:** Fazendo a string ficar maiúscula

```c#
Console.WriteLine(txtTexto.Text.ToUpper());
```

